<!doctype html><html lang=en><head><title>GitHub Actions :: Alex Day — A rambling storage system</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=description content="Easy code is easy to compile and run. That has and always will be true. However, once the code you write spans across multiple classes, files, or even packages it can be hard to properly test, compile, and release this software. Continuous integration (CI) tries to solve this problem. By defining a pipeline of actions to take your code from source to product that run the same way every time."><meta name=keywords content="Coding,PhD,Clemson"><meta name=robots content="noodp"><link rel=canonical href=/posts/github-actions/><link rel=stylesheet href=/assets/style.css><link rel=stylesheet href=/assets/green.css><link rel=stylesheet href=/style.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.ico><meta name=twitter:card content="summary"><meta name=twitter:site content><meta name=twitter:creator content><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="GitHub Actions :: Alex Day"><meta property="og:description" content="GitHub's new continuous integration framework is absolutely amazing"><meta property="og:url" content="/posts/github-actions/"><meta property="og:site_name" content="GitHub Actions"><meta property="og:image" content="/favicon.ico"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2020-05-04 00:00:00 +0000 UTC"><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link rel=manifest href=/manifest.json><script type=text/javascript>if('serviceWorker'in navigator){navigator.serviceWorker.register('/sw.js',{scope:'/'}).then(function(registration){console.log('Service Worker Registered');});navigator.serviceWorker.ready.then(function(registration){console.log('Service Worker Ready');});}</script></head><body><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>Alex Day</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/about>About</a></li><li><a href=/posts>Posts</a></li><li><a href=/projects>Projects</a></li><li><a href=/papers>Papers</a></li><li><a href=/talks>Talks</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/about>About</a></li><li><a href=/posts>Posts</a></li><li><a href=/projects>Projects</a></li><li><a href=/papers>Papers</a></li><li><a href=/talks>Talks</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=/posts/github-actions/>GitHub Actions</a></h1><div class=post-meta><span class=post-date>2020-05-04</span></div><span class=post-tags>#<a href=/tags/github/>GitHub,</a>&nbsp;
#<a href=/tags/ci/>CI</a>&nbsp;</span><div class=post-content><div><p>Easy code is easy to compile and run. That has and always will be true. However,
once the code you write spans across multiple classes, files, or even packages
it can be hard to properly test, compile, and release this software. Continuous
integration (CI) tries to solve this problem. By defining a pipeline of actions
to take your code from source to product that run the same way every time. Docker
(and containerization in general) augments this process by providing easy to use
clean-slate images that these pipelines can built up on. Always starting at the
same point and then running the same actions provides a stable pipeline that can
reliably test, compile, and release a piece of software. This, in turn, provides
a reliable platform that allows developers to more easily solve more problems.</p><h2 id=headline-1>GitHub Actions</h2><p>There are umpteen solutions for continuous integration. This includes <a href=www.jenkins.io>Jenkins</a>,
<a href=https://cloud.google.com/tekton/>Tekton</a>, and <a href=https://github.com/features/actions>GitHub Actions</a>. Over the past couple of weeks I have been using
GitHub Actions (first for work and most recently for this website) and I have
found that it drastically increases my productivity by reducing the time I spend
on either producing a wheel, running pytest, or generating and uploading this
Hugo-driven site.</p><h3 id=headline-2>Pipeline</h3><p>GitHub uses YAML files to define a CI pipeline. A pipeline is a set of actions
in an explicit order. These actions can either be a command to the operating
system (e.g. <code>echo "Hello World"</code> or <code>curl www.google.com</code>) or a group of
commands developed by someone (e.g. <a href=https://github.com/actions/checkout>checking out a repo</a> or <a href=https://github.com/peaceiris/actions-hugo>generating a hugo
site</a>). All these actions run on a fresh instance of a virtual machine. There are
two choices when it comes to these virtual machines. You can either host your
own virtual machine, or use one that GitHub hosts (GitHub hosted platforms are
Windows Server 2019, Ubuntu 18.04 and 16.04, and MacOS Catalina).</p><p>Below is the pipeline for this site. The pipeline's environment is Ubuntu 18.04 and
there are four actions this pipeline takes. The first action
(<a href=https://github.com/actions/checkout>actions/checkout@v2</a>) checks the site repo out. Because the definition for this
workflow is in the <a href=https://github.com/AlexanderDavid/alexanderdavid.github.io/tree/devel>devel</a> branch that is the branch that this action checks out.
The next action (<a href=https://www.github.com/peaceiris/actions-hugo>peaceiris/actions-hugo@v2</a>) installs Hugo v0.68.3. The site is
then built using a simple action that executes <code>hugo --minify</code>. This builds the
site into the <code>public</code> directory. The last action (<a href=https://www.github.com/peaceiris/actions-gh-pages>peaceiris/actions-gh-pages</a>)
publishes the <code>public</code> directory into the master branch and adds the CNAME file
that allows me to use my own domain name.</p><div class="src src-yaml"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#75715e># .github/actions/main.yml</span>
<span style=color:#66d9ef>name</span>: Build Hugo

<span style=color:#66d9ef>on</span>:
  <span style=color:#66d9ef>push</span>:
    <span style=color:#66d9ef>branches</span>:
      - devel

<span style=color:#66d9ef>jobs</span>:
  <span style=color:#66d9ef>deploy</span>:
    <span style=color:#66d9ef>runs-on</span>: ubuntu<span style=color:#ae81ff>-18.04</span>
    <span style=color:#66d9ef>steps</span>:
      - <span style=color:#66d9ef>uses</span>: actions/checkout@v2

      - <span style=color:#66d9ef>name</span>: Setup Hugo
        <span style=color:#66d9ef>uses</span>: peaceiris/actions-hugo@v2
        <span style=color:#66d9ef>with</span>:
          <span style=color:#66d9ef>hugo-version</span>: <span style=color:#e6db74>&#39;0.68.3&#39;</span>

      - <span style=color:#66d9ef>name</span>: Build
        <span style=color:#66d9ef>run</span>: hugo --minify

      - <span style=color:#66d9ef>name</span>: Deploy
        <span style=color:#66d9ef>uses</span>: peaceiris/actions-gh-pages@v3
        <span style=color:#66d9ef>with</span>:
          <span style=color:#66d9ef>github_token</span>: ${{ secrets.GITHUB_TOKEN }}
          <span style=color:#66d9ef>publish_dir</span>: ./public
          <span style=color:#66d9ef>publish_branch</span>: master
          <span style=color:#66d9ef>cname</span>: www.alexday.me</code></pre></div></div><p>This is all that GitHub needs to reliably compile and serve my website. Prior to
this I had to compile the website locally into a different directory and then
commit and push that to the master branch of the repository. Now I can just
compile and push to the development branch (something I was already doing) and
the changes are immediately reflected by my website.</p><h3 id=headline-3>Secrets</h3><p>Some pipelines need sensitive variables to function correctly. Rather than commit these variables to the codebase you can enter them as a secret in the settings section of the repository. An action can access these secrets by using the following syntax: <code>${{ secrets.SECRET_NAME }}</code>. The Hugo deployment pipeline uses the <code>GITHUB_TOKEN</code> secret that comes by default with every repository so that it can push the changes back to the master branch.</p><h2 id=headline-4>Conclusions</h2><p>GitHub Actions are an amazing addition to the platform. They allow small projects to enable a free and easy continuous integration pipeline while also being able to scale to larger projects. While it is not the end-all-be-all for CI, it is certainly a good jumping off point if you want to start investigating this world. There are some features that were not discussed in this post (namely artifacts as I haven't played with them much), but more information is available in the <a href=https://help.github.com/en/actions>documentation</a>.</p></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button next"><a href=/posts/emacs-for-email/><span class=button__text>Emacs for Email</span>
<span class=button__icon>→</span></a></span></div></div><script src=https://utteranc.es/client.js repo=AlexanderDavid/alexanderdavid.github.io issue-term=pathname theme=photon-dark crossorigin=anonymous async></script></div></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>© 2020 Alex Day</span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=/assets/main.js></script><script src=/assets/prism.js></script></div></body></html>